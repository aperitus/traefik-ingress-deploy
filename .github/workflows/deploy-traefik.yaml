name: Deploy Traefik Ingress (AKS)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: GitHub Environment to use
        required: true
        type: choice
        options:
          - dev
          - preprod
          - prod

      routing_mode:
        description: Routing mode - ingress (Ingress), gateway (Gateway API), both (transition)
        required: true
        type: choice
        options:
          - both
          - gateway
          - ingress
        default: both

      enable_traefik_dashboard:
        description: Enable Traefik API/Dashboard and run post-deploy API check (internal only)
        required: false
        type: boolean
        default: false

      debug_values:
        description: "Upload debug artifacts (generated values; and if TLS enabled, certificate diagnostics â€” certificate/public-key only)"
        required: false
        type: boolean
        default: false

      enable_tls:
        description: Enable TLS on the Traefik data-plane using a wildcard cert stored in GitHub secrets (Gateway HTTPS listener + TLS secret in traefik namespace; also redirects HTTP -> HTTPS)
        required: false
        type: boolean
        default: true

      aks_resource_group:
        description: AKS resource group (optional; defaults to vars.AKS_RESOURCE_GROUP)
        required: false
        type: string
        default: ""

      aks_cluster_name:
        description: AKS cluster name (optional; defaults to vars.AKS_CLUSTER_NAME)
        required: false
        type: string
        default: ""

      use_admin_credentials:
        description: Use AKS admin kubeconfig (adds --admin to az aks get-credentials)
        required: false
        type: boolean
        default: false

      traefik_chart_version:
        description: Traefik chart version (optional; defaults to vars.TRAEFIK_CHART_VERSION)
        required: false
        type: string
        default: ""

      helm_timeout:
        description: Helm timeout (optional; defaults to vars.HELM_TIMEOUT)
        required: false
        type: string
        default: ""

concurrency:
  group: traefik-ingress-deploy
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  render-values-artifact:
    name: Render values artifact (debug)
    if: ${{ inputs.debug_values == true }}
    runs-on: self-hosted
    environment: ${{ inputs.environment }}
    timeout-minutes: 10

    env:
      # Render-only job: builds the values file deterministically and uploads it as an artifact
      # even if the deploy job fails.

      # Image override placeholders (no secrets)
      IMAGE_PULL_SECRET_NAME: ${{ secrets.IMAGE_PULL_SECRET_NAME }}
      TRAEFIK_IMAGE_REGISTRY: ${{ vars.TRAEFIK_IMAGE_REGISTRY || secrets.REGISTRY_SERVER }}
      TRAEFIK_IMAGE_REPOSITORY: ${{ vars.TRAEFIK_IMAGE_REPOSITORY || 'library/traefik' }}
      TRAEFIK_IMAGE_TAG: ${{ vars.TRAEFIK_IMAGE_TAG || '' }}
      TRAEFIK_LB_IPV4: ${{ vars.TRAEFIK_LB_IPV4 || '' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Verify Python on runner
        shell: bash
        run: |
          set -euo pipefail
          command -v python3 >/dev/null

      - name: Render Helm values (no secret material printed)
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          mkdir -p artifacts

          python3 - <<'PY'
          import os
          from pathlib import Path

          tpl = Path('helm/traefik/values.template.yaml').read_text(encoding='utf-8')

          repl = {
            '<IMAGE_PULL_SECRET_NAME>': os.environ['IMAGE_PULL_SECRET_NAME'],
            '<TRAEFIK_IMAGE_REGISTRY>': os.environ['TRAEFIK_IMAGE_REGISTRY'],
            '<TRAEFIK_IMAGE_REPOSITORY>': os.environ['TRAEFIK_IMAGE_REPOSITORY'],
            '<TRAEFIK_IMAGE_TAG>': os.environ.get('TRAEFIK_IMAGE_TAG', ''),
            '<TRAEFIK_LB_IPV4>': os.environ.get('TRAEFIK_LB_IPV4', ''),
            # Back-compat placeholder (older template)
            '<REGISTRY_SERVER>': os.environ['TRAEFIK_IMAGE_REGISTRY'],
          }
          for k, v in repl.items():
            tpl = tpl.replace(k, v)

          out = Path('artifacts/values.traefik.generated.yaml')
          out.write_text(tpl, encoding='utf-8')
          PY

          chmod 600 artifacts/values.traefik.generated.yaml

          # Lightweight, non-sensitive run context to help debug failures.
          {
            echo "environment=${{ inputs.environment }}"
            echo "routing_mode=${{ inputs.routing_mode }}"
            echo "enable_traefik_dashboard=${{ inputs.enable_traefik_dashboard }}"
            echo "workflow_ref=${GITHUB_REF}"
            echo "workflow_sha=${GITHUB_SHA}"
          } > artifacts/run-context.txt

      - name: Upload rendered values artifact
        uses: actions/upload-artifact@v3
        with:
          name: values-traefik-generated
          path: |
            artifacts/values.traefik.generated.yaml
            artifacts/run-context.txt
          if-no-files-found: error
          retention-days: 7

  tls-diagnostics-artifact:
    name: TLS diagnostics artifact (debug)
    if: ${{ inputs.enable_tls == true && inputs.debug_values == true }}
    runs-on: self-hosted
    environment: ${{ inputs.environment }}
    timeout-minutes: 10

    env:
      TLS_SECRET_NAME: ${{ vars.TLS_SECRET_NAME || 'wildcard-tls' }}

      # Wildcard certificate material (recommended names in GH secrets: ELOKO_WILDCARD_CRT / ELOKO_WILDCARD_KEY)
      # Back-compat fallback: WILDCARD_CRT / WILDCARD_KEY
      WILDCARD_CRT: ${{ secrets.ELOKO_WILDCARD_CRT || secrets.WILDCARD_CRT || '' }}
      WILDCARD_KEY: ${{ secrets.ELOKO_WILDCARD_KEY || secrets.WILDCARD_KEY || '' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Generate TLS diagnostics (no private key upload)
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          mkdir -p artifacts

          CERT_FILE="artifacts/wildcard.crt"
          KEY_FILE="artifacts/_wildcard.key"

          # Write PEM material to files without printing to logs.
          python3 - <<'PY'
          import os
          from pathlib import Path

          crt = os.environ.get('WILDCARD_CRT', '').replace('\r\n', '\n').replace('\r', '')
          key = os.environ.get('WILDCARD_KEY', '').replace('\r\n', '\n').replace('\r', '')

          Path('artifacts/wildcard.crt').write_text(crt, encoding='utf-8')
          Path('artifacts/_wildcard.key').write_text(key, encoding='utf-8')
          PY

          chmod 600 "${CERT_FILE}" "${KEY_FILE}" || true

          {
            echo "tls_secret_name=${TLS_SECRET_NAME}"
            echo "cert_bytes=$(wc -c < "${CERT_FILE}" 2>/dev/null || echo 0)"
            echo "key_bytes=$(wc -c < "${KEY_FILE}" 2>/dev/null || echo 0)"
            echo "cert_begin_header_present=$(grep -F -q -- '-----BEGIN CERTIFICATE-----' "${CERT_FILE}" && echo true || echo false)"
            echo "cert_end_footer_present=$(grep -F -q -- '-----END CERTIFICATE-----' "${CERT_FILE}" && echo true || echo false)"
            echo "key_begin_header_present=$(grep -E -q -- '-----BEGIN (RSA |EC )?PRIVATE KEY-----|-----BEGIN PRIVATE KEY-----' "${KEY_FILE}" && echo true || echo false)"
            echo "key_end_footer_present=$(grep -E -q -- '-----END (RSA |EC )?PRIVATE KEY-----|-----END PRIVATE KEY-----' "${KEY_FILE}" && echo true || echo false)"
            echo "cert_pem_blocks=$(grep -c 'BEGIN CERTIFICATE' "${CERT_FILE}" 2>/dev/null || echo 0)"
            # Detect literal "\n" sequences (common when PEM was pasted as a JSON-escaped string).
            echo "cert_literal_backslash_n_count=$(grep -o '\\n' "${CERT_FILE}" 2>/dev/null | wc -l || echo 0)"
            echo "key_literal_backslash_n_count=$(grep -o '\\n' "${KEY_FILE}" 2>/dev/null | wc -l || echo 0)"
            echo
            echo "--- cert first/last line (may appear as *** due to GitHub secret masking) ---"
            head -n 1 "${CERT_FILE}" 2>/dev/null || true
            tail -n 1 "${CERT_FILE}" 2>/dev/null || true
            echo
            echo "--- openssl x509 parse ---"
            openssl x509 -in "${CERT_FILE}" -noout -subject -issuer -dates -fingerprint -sha256 2>&1 || true
            echo
            echo "--- openssl pkey parse (no key output) ---"
            openssl pkey -in "${KEY_FILE}" -noout -passin pass: 2>&1 || true
          } > artifacts/tls-diagnostics.txt

          # If the key is parseable, export public key only (safe) and compute a match signal.
          if openssl pkey -in "${KEY_FILE}" -pubout -out artifacts/wildcard.public.pem -passin pass: 2>/dev/null; then
            chmod 600 artifacts/wildcard.public.pem || true

            CERT_PUB_HASH="$(openssl x509 -in "${CERT_FILE}" -pubkey -noout 2>/dev/null | openssl pkey -pubin -outform DER 2>/dev/null | openssl dgst -sha256 | awk '{print $2}' || true)"
            KEY_PUB_HASH="$(openssl pkey -in "${KEY_FILE}" -pubout -outform DER 2>/dev/null | openssl dgst -sha256 | awk '{print $2}' || true)"

            {
              echo "cert_pubkey_sha256=${CERT_PUB_HASH}"
              echo "key_pubkey_sha256=${KEY_PUB_HASH}"
              if [[ -n "${CERT_PUB_HASH}" && -n "${KEY_PUB_HASH}" && "${CERT_PUB_HASH}" == "${KEY_PUB_HASH}" ]]; then
                echo "cert_key_match=true"
              else
                echo "cert_key_match=false"
              fi
            } > artifacts/tls-match.txt
          else
            echo "cert_key_match=unknown" > artifacts/tls-match.txt
          fi

          # Do NOT leave the private key file in artifacts; keep it only transiently for diagnostics.
          rm -f "${KEY_FILE}" || true

      - name: Upload TLS diagnostics artifact
        if: ${{ always() }}
        uses: actions/upload-artifact@v3
        with:
          name: tls-diagnostics
          path: |
            artifacts/tls-diagnostics.txt
            artifacts/tls-match.txt
            artifacts/wildcard.crt
            artifacts/wildcard.public.pem
          if-no-files-found: warn
          retention-days: 3

  deploy:
    name: Deploy Traefik Ingress
    runs-on: self-hosted
    environment: ${{ inputs.environment }}
    timeout-minutes: 45

    env:
      TRAEFIK_NAMESPACE: traefik
      TRAEFIK_RELEASE: traefik

      # Isolate Azure CLI state to avoid runner-global cache/token issues.
      AZURE_CONFIG_DIR: /tmp/azcfg

      # Isolate kubeconfig to avoid runner-global state.
      KUBECONFIG: /tmp/kubeconfig

      # Non-secret defaults from Environment/Repo variables; workflow_dispatch inputs override vars.
      AKS_RESOURCE_GROUP: ${{ inputs.aks_resource_group || vars.AKS_RESOURCE_GROUP }}
      AKS_CLUSTER_NAME: ${{ inputs.aks_cluster_name || vars.AKS_CLUSTER_NAME }}
      TRAEFIK_CHART_VERSION: ${{ inputs.traefik_chart_version || vars.TRAEFIK_CHART_VERSION }}
      HELM_TIMEOUT: ${{ inputs.helm_timeout || vars.HELM_TIMEOUT }}

      ROUTING_MODE: ${{ inputs.routing_mode }}
      ENABLE_TRAEFIK_DASHBOARD: ${{ inputs.enable_traefik_dashboard }}
      DEBUG_VALUES: ${{ inputs.debug_values }}

      ENABLE_TLS: ${{ inputs.enable_tls }}

      # Helm chart repo (Traefik official repo by default)
      TRAEFIK_HELM_REPO_URL: ${{ vars.TRAEFIK_HELM_REPO_URL || 'https://traefik.github.io/charts' }}

      # Azure SP auth (GHES is private; do not use OIDC federation)
      AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      DEPLOY_CLIENT_ID: ${{ secrets.DEPLOY_CLIENT_ID }}
      DEPLOY_SECRET: ${{ secrets.DEPLOY_SECRET }}

      # Nexus registry credentials (required)
      REGISTRY_SERVER: ${{ secrets.REGISTRY_SERVER }}
      REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME }}
      REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
      IMAGE_PULL_SECRET_NAME: ${{ secrets.IMAGE_PULL_SECRET_NAME }}

      # Image override: chart remains traefik/traefik; image repo is Nexus-only (default library/traefik).
      TRAEFIK_IMAGE_REGISTRY: ${{ vars.TRAEFIK_IMAGE_REGISTRY || secrets.REGISTRY_SERVER }}
      TRAEFIK_IMAGE_REPOSITORY: ${{ vars.TRAEFIK_IMAGE_REPOSITORY || 'library/traefik' }}
      TRAEFIK_IMAGE_TAG: ${{ vars.TRAEFIK_IMAGE_TAG || '' }}

      # In-cluster test image (must be Nexus-hosted) used ONLY when ENABLE_TRAEFIK_DASHBOARD=true
      TRAEFIK_TEST_IMAGE: ${{ vars.TRAEFIK_TEST_IMAGE || '' }}

      # Optional: pin a specific ILB IP (must be free in subnet). If unset, Azure assigns.
      TRAEFIK_LB_IPV4: ${{ vars.TRAEFIK_LB_IPV4 || '' }}

      # Optional DNS update (Azure Private DNS)
      DNS_ENABLED: ${{ vars.DNS_ENABLED || secrets.DNS_ENABLED || 'false' }}
      PRIVATE_DNS_ZONE_SUBSCRIPTION_ID: ${{ vars.PRIVATE_DNS_ZONE_SUBSCRIPTION_ID || secrets.PRIVATE_DNS_ZONE_SUBSCRIPTION_ID || '' }}
      PRIVATE_DNS_ZONE_RESOURCE_GROUP: ${{ vars.PRIVATE_DNS_ZONE_RESOURCE_GROUP || secrets.PRIVATE_DNS_ZONE_RESOURCE_GROUP || '' }}
      PRIVATE_DNS_ZONE_NAME: ${{ vars.PRIVATE_DNS_ZONE_NAME || secrets.PRIVATE_DNS_ZONE_NAME || '' }}
      PRIVATE_DNS_A_RECORD_NAME: ${{ vars.PRIVATE_DNS_A_RECORD_NAME || secrets.PRIVATE_DNS_A_RECORD_NAME || '' }}

      # Gateway API hardening (namespace selector for allowedRoutes)
      GATEWAY_ALLOWED_ROUTES_FROM: ${{ vars.GATEWAY_ALLOWED_ROUTES_FROM || 'Selector' }}
      GATEWAY_ALLOWED_ROUTES_LABEL_KEY: ${{ vars.GATEWAY_ALLOWED_ROUTES_LABEL_KEY || 'traefik-gateway-access' }}
      GATEWAY_ALLOWED_ROUTES_LABEL_VALUE: ${{ vars.GATEWAY_ALLOWED_ROUTES_LABEL_VALUE || 'enabled' }}

      # IMPORTANT: Traefik chart entrypoint port for "web" in values.template.yaml is 8000 by default.
      # The Gateway listener port should align to entrypoint port to avoid controller mismatches.
      GATEWAY_LISTENER_WEB_PORT: ${{ vars.GATEWAY_LISTENER_WEB_PORT || '8000' }}

      # TLS (optional)
      # - For Gateway API, TLS is configured on the Gateway listener (HTTPS) and references a Secret in the traefik namespace.
      # - For classic Ingress, each app namespace must have its own TLS Secret referenced by the Ingress spec.
      TLS_SECRET_NAME: ${{ vars.TLS_SECRET_NAME || 'wildcard-tls' }}
      GATEWAY_LISTENER_WEBSECURE_PORT: ${{ vars.GATEWAY_LISTENER_WEBSECURE_PORT || '8443' }}

      # Wildcard certificate material (recommended names in GH secrets: ELOKO_WILDCARD_CRT / ELOKO_WILDCARD_KEY)
      # Back-compat fallback: WILDCARD_CRT / WILDCARD_KEY
      WILDCARD_CRT: ${{ secrets.ELOKO_WILDCARD_CRT || secrets.WILDCARD_CRT || '' }}
      WILDCARD_KEY: ${{ secrets.ELOKO_WILDCARD_KEY || secrets.WILDCARD_KEY || '' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Verify toolchain on runner
        shell: bash
        run: |
          set -euo pipefail
          command -v az >/dev/null
          command -v kubectl >/dev/null
          command -v helm >/dev/null
          command -v python3 >/dev/null
          command -v kubelogin >/dev/null
          command -v openssl >/dev/null
          az version
          kubectl version --client=true
          helm version
          kubelogin --version || true

      - name: Azure login (Service Principal + secret)
        shell: bash
        run: |
          set -euo pipefail
          : "${DEPLOY_CLIENT_ID:?DEPLOY_CLIENT_ID empty}"
          : "${DEPLOY_SECRET:?DEPLOY_SECRET empty}"
          : "${AZURE_TENANT_ID:?AZURE_TENANT_ID empty}"
          : "${AZURE_SUBSCRIPTION_ID:?AZURE_SUBSCRIPTION_ID empty}"

          # Force non-interactive Azure CLI behaviour by isolating config and clearing any stale context.
          # This ensures deterministic behaviour on long-lived self-hosted runners.
          rm -rf "${AZURE_CONFIG_DIR}" 2>/dev/null || true
          mkdir -p "${AZURE_CONFIG_DIR}"
          az logout --output=none 2>/dev/null || true
          az account clear --output=none 2>/dev/null || true

          az login             --service-principal             --username="${DEPLOY_CLIENT_ID}"             --password="${DEPLOY_SECRET}"             --tenant="${AZURE_TENANT_ID}"             --output=none

          az account set --subscription="${AZURE_SUBSCRIPTION_ID}"

      - name: Validate required variables and normalise Helm timeout
        shell: bash
        run: |
          set -euo pipefail

          : "${AKS_RESOURCE_GROUP:?Set inputs.aks_resource_group or vars.AKS_RESOURCE_GROUP}"
          : "${AKS_CLUSTER_NAME:?Set inputs.aks_cluster_name or vars.AKS_CLUSTER_NAME}"
          : "${TRAEFIK_CHART_VERSION:?Set inputs.traefik_chart_version or vars.TRAEFIK_CHART_VERSION}"
          : "${HELM_TIMEOUT:?Set inputs.helm_timeout or vars.HELM_TIMEOUT}"

          # Normalise Helm timeout:
          # - If value is purely numeric (e.g. "10"), treat as minutes ("10m")
          # - If it already has a unit suffix (s/m/h), keep as-is
          if [[ "${HELM_TIMEOUT}" =~ ^[0-9]+$ ]]; then
            HELM_TIMEOUT="${HELM_TIMEOUT}m"
          fi
          if [[ ! "${HELM_TIMEOUT}" =~ ^[0-9]+[smh]$ ]]; then
            echo "ERROR: HELM_TIMEOUT must be like '10m', '600s', '5h' (or a number of minutes like '10'). Got: '${HELM_TIMEOUT}'" >&2
            exit 1
          fi
          echo "HELM_TIMEOUT=${HELM_TIMEOUT}" >> "${GITHUB_ENV}"

          if [[ "${ROUTING_MODE}" == "gateway" || "${ROUTING_MODE}" == "both" ]]; then
            if [[ ! "${GATEWAY_LISTENER_WEB_PORT}" =~ ^[0-9]+$ ]]; then
              echo "ERROR: GATEWAY_LISTENER_WEB_PORT must be numeric. Got: '${GATEWAY_LISTENER_WEB_PORT}'" >&2
              exit 1
            fi

            if [[ "${GATEWAY_ALLOWED_ROUTES_FROM}" == "Selector" ]]; then
              if [[ ! "${GATEWAY_ALLOWED_ROUTES_LABEL_VALUE}" =~ [A-Za-z] ]]; then
                echo "ERROR: GATEWAY_ALLOWED_ROUTES_LABEL_VALUE must include at least one letter (e.g. 'enabled'). Got: '${GATEWAY_ALLOWED_ROUTES_LABEL_VALUE}'" >&2
                exit 1
              fi
              case "${GATEWAY_ALLOWED_ROUTES_LABEL_VALUE,,}" in
                true|false|yes|no|on|off|null|~)
                  echo "ERROR: GATEWAY_ALLOWED_ROUTES_LABEL_VALUE looks like a YAML boolean/null. Use a non-boolean string like 'enabled'." >&2
                  exit 1
                  ;;
              esac
            fi
          fi

          # Dashboard test image required only when enabled
          if [[ "${ENABLE_TRAEFIK_DASHBOARD}" == "true" ]]; then
            : "${TRAEFIK_TEST_IMAGE:?Set vars.TRAEFIK_TEST_IMAGE to a Nexus-hosted image containing curl or wget}"
          fi

          # TLS material required only when enabled
          if [[ "${ENABLE_TLS}" == "true" ]]; then
            : "${TLS_SECRET_NAME:?Set vars.TLS_SECRET_NAME (or accept default 'wildcard-tls')}"
            : "${WILDCARD_CRT:?Set secrets.ELOKO_WILDCARD_CRT (or secrets.WILDCARD_CRT) to the PEM certificate/full chain}"
            : "${WILDCARD_KEY:?Set secrets.ELOKO_WILDCARD_KEY (or secrets.WILDCARD_KEY) to the PEM private key}"
          fi

      - name: Get AKS credentials (Entra) + kubelogin convert
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          ADMIN_FLAG=""
          if [[ "${{ inputs.use_admin_credentials }}" == "true" ]]; then
            ADMIN_FLAG="--admin"
          fi

          az aks get-credentials             --resource-group="${AKS_RESOURCE_GROUP}"             --name="${AKS_CLUSTER_NAME}"             ${ADMIN_FLAG}             --file="${KUBECONFIG}"             --overwrite-existing

          if [[ "${{ inputs.use_admin_credentials }}" == "true" ]]; then
            echo "Using admin kubeconfig; skipping kubelogin convert."
            exit 0
          fi

          kubelogin convert-kubeconfig             --login="spn"             --client-id="${DEPLOY_CLIENT_ID}"             --client-secret="${DEPLOY_SECRET}"             --tenant-id="${AZURE_TENANT_ID}"             --kubeconfig="${KUBECONFIG}"

          if grep --quiet "command: azurecli" "${KUBECONFIG}"; then
            echo "ERROR: kubeconfig still references azurecli exec (interactive). kubelogin convert failed." >&2
            exit 1
          fi

      - name: Ensure Traefik namespace
        shell: bash
        run: |
          set -euo pipefail
          kubectl get namespace "${TRAEFIK_NAMESPACE}" >/dev/null 2>&1 || kubectl create namespace "${TRAEFIK_NAMESPACE}"

      - name: Create/update imagePullSecret (Nexus) in Traefik namespace
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          kubectl --namespace="${TRAEFIK_NAMESPACE}" create secret docker-registry "${IMAGE_PULL_SECRET_NAME}"             --docker-server="${REGISTRY_SERVER}"             --docker-username="${REGISTRY_USERNAME}"             --docker-password="${REGISTRY_PASSWORD}"             --dry-run=client --output=yaml             | kubectl apply --filename=-

      - name: Create/update TLS secret (wildcard) in Traefik namespace
        if: ${{ inputs.enable_tls == true }}
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          : "${TLS_SECRET_NAME:?TLS_SECRET_NAME empty}"
          : "${WILDCARD_CRT:?WILDCARD_CRT empty}"
          : "${WILDCARD_KEY:?WILDCARD_KEY empty}"

          CERT_FILE="/tmp/wildcard.crt"
          KEY_FILE="/tmp/wildcard.key"
          SECRET_YAML="/tmp/${TLS_SECRET_NAME}.tls-secret.yaml"
          export CERT_FILE KEY_FILE

          # Write PEM material to temp files without printing to logs.
          # Note: we normalise CRLF -> LF to avoid PEM parsing issues.
          python3 - <<'PY'
          import os
          from pathlib import Path

          crt = os.environ['WILDCARD_CRT'].replace('\r\n', '\n').replace('\r', '')
          key = os.environ['WILDCARD_KEY'].replace('\r\n', '\n').replace('\r', '')

          Path(os.environ['CERT_FILE']).write_text(crt, encoding='utf-8')
          Path(os.environ['KEY_FILE']).write_text(key, encoding='utf-8')
          PY

          chmod 600 "${CERT_FILE}" "${KEY_FILE}"

          # Validate PEM markers (fast fail with actionable message).
          if [[ ! -s "${CERT_FILE}" ]]; then
            echo "ERROR: Certificate file is empty after writing secrets. Check secrets.ELOKO_WILDCARD_CRT." >&2
            exit 1
          fi
          if [[ ! -s "${KEY_FILE}" ]]; then
            echo "ERROR: Key file is empty after writing secrets. Check secrets.ELOKO_WILDCARD_KEY." >&2
            exit 1
          fi

          # Patterns start with dashes; use `--` to prevent grep treating them as options.
          if ! grep -F -q -- "-----BEGIN CERTIFICATE-----" "${CERT_FILE}"; then
            echo "ERROR: WILDCARD_CRT does not look like PEM. Expected '-----BEGIN CERTIFICATE-----' header." >&2
            echo "Hint: store the raw PEM text (not base64, not PFX/DER)." >&2
            echo "Certificate first line: $(head -n 1 "${CERT_FILE}" | tr -d '\r')" >&2
            exit 1
          fi
          if ! grep -F -q -- "-----END CERTIFICATE-----" "${CERT_FILE}"; then
            echo "ERROR: WILDCARD_CRT missing PEM footer '-----END CERTIFICATE-----'." >&2
            echo "Certificate last line: $(tail -n 1 "${CERT_FILE}" | tr -d '\r')" >&2
            exit 1
          fi

          if ! grep -E -q -- "-----BEGIN (RSA |EC )?PRIVATE KEY-----|-----BEGIN PRIVATE KEY-----" "${KEY_FILE}"; then
            echo "ERROR: WILDCARD_KEY does not look like PEM. Expected '-----BEGIN ... PRIVATE KEY-----' header." >&2
            echo "Hint: store the raw PEM private key (not base64, not PFX, not encrypted with a passphrase)." >&2
            echo "Key first line: $(head -n 1 "${KEY_FILE}" | tr -d '\r')" >&2
            exit 1
          fi
          if ! grep -E -q -- "-----END (RSA |EC )?PRIVATE KEY-----|-----END PRIVATE KEY-----" "${KEY_FILE}"; then
            echo "ERROR: WILDCARD_KEY missing PEM footer '-----END ... PRIVATE KEY-----'." >&2
            echo "Key last line: $(tail -n 1 "${KEY_FILE}" | tr -d '\r')" >&2
            exit 1
          fi

          # Parse certificate (safe to print minimal metadata) and ensure the key is parseable.
          echo "Certificate PEM blocks: $(grep -c 'BEGIN CERTIFICATE' "${CERT_FILE}" || true)"
          openssl x509 -in "${CERT_FILE}" -noout -subject -issuer -dates -fingerprint -sha256
          # -passin pass: avoids interactive prompts if the key is encrypted.
          openssl pkey -in "${KEY_FILE}" -noout -passin pass: >/dev/null

          # Ensure certificate and key match (works for RSA/ECDSA): compare derived public-key hashes.
          CERT_PUB_HASH="$(openssl x509 -in "${CERT_FILE}" -pubkey -noout | openssl pkey -pubin -outform DER 2>/dev/null | openssl dgst -sha256 | awk '{print $2}')"
          KEY_PUB_HASH="$(openssl pkey -in "${KEY_FILE}" -pubout -outform DER 2>/dev/null | openssl dgst -sha256 | awk '{print $2}')"
          if [[ -z "${CERT_PUB_HASH}" || -z "${KEY_PUB_HASH}" || "${CERT_PUB_HASH}" != "${KEY_PUB_HASH}" ]]; then
            echo "ERROR: Certificate and private key do not match (public key hash mismatch)." >&2
            echo "Check you pasted the correct key for the wildcard certificate." >&2
            exit 1
          fi

          # Create the TLS secret deterministically (avoid pipelines that obscure root error).
          kubectl --namespace="${TRAEFIK_NAMESPACE}" create secret tls "${TLS_SECRET_NAME}" \
            --cert="${CERT_FILE}" \
            --key="${KEY_FILE}" \
            --dry-run=client --output=yaml \
            > "${SECRET_YAML}"

          kubectl apply --filename="${SECRET_YAML}"

          # Cleanup to reduce secret material residency on the runner.
          rm -f "${CERT_FILE}" "${KEY_FILE}" "${SECRET_YAML}"

      - name: Render Helm values (no secret material printed)
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          python3 - <<'PY'
          import os
          from pathlib import Path

          tpl = Path('helm/traefik/values.template.yaml').read_text(encoding='utf-8')

          repl = {
            '<IMAGE_PULL_SECRET_NAME>': os.environ['IMAGE_PULL_SECRET_NAME'],
            '<TRAEFIK_IMAGE_REGISTRY>': os.environ['TRAEFIK_IMAGE_REGISTRY'],
            '<TRAEFIK_IMAGE_REPOSITORY>': os.environ['TRAEFIK_IMAGE_REPOSITORY'],
            '<TRAEFIK_IMAGE_TAG>': os.environ.get('TRAEFIK_IMAGE_TAG', ''),
            '<TRAEFIK_LB_IPV4>': os.environ.get('TRAEFIK_LB_IPV4', ''),
            # Back-compat placeholder (older template)
            '<REGISTRY_SERVER>': os.environ['TRAEFIK_IMAGE_REGISTRY'],
          }
          for k, v in repl.items():
            tpl = tpl.replace(k, v)

          out = Path('/tmp/values.traefik.generated.yaml')
          out.write_text(tpl, encoding='utf-8')
          PY

          chmod 600 /tmp/values.traefik.generated.yaml

      - name: Install/upgrade Traefik (official chart; images pulled from Nexus)
        shell: bash
        run: |
          set -euo pipefail

          helm repo add traefik "${TRAEFIK_HELM_REPO_URL}"
          helm repo update

          EXTRA_ARGS=()

          # We build additionalArguments as an indexed list so multiple features can append args safely.
          # (TLS redirect + optional dashboard/API enablement)
          AA_IDX=0

          # routing mode toggles
          if [[ "${ROUTING_MODE}" == "ingress" || "${ROUTING_MODE}" == "both" ]]; then
            EXTRA_ARGS+=(--set "providers.kubernetesIngress.enabled=true")
          else
            EXTRA_ARGS+=(--set "providers.kubernetesIngress.enabled=false")
          fi

          if [[ "${ROUTING_MODE}" == "gateway" || "${ROUTING_MODE}" == "both" ]]; then
            EXTRA_ARGS+=(--set "providers.kubernetesGateway.enabled=true")

            # IMPORTANT:
            # Disable the chart-managed Gateway resource to avoid template type issues.
            # We apply the Gateway (and GatewayClass) ourselves in a later step.
            EXTRA_ARGS+=(--set "gateway.enabled=false")
          else
            EXTRA_ARGS+=(--set "providers.kubernetesGateway.enabled=false")
            EXTRA_ARGS+=(--set "gateway.enabled=false")
          fi

          # If TLS is enabled (default), enforce Option B: keep HTTP open but redirect HTTP -> HTTPS.
          # This is implemented as an entryPoint redirect from 'web' to 'websecure'.
          if [[ "${ENABLE_TLS}" == "true" ]]; then
            EXTRA_ARGS+=(--set-string=additionalArguments[${AA_IDX}]=--entrypoints.web.http.redirections.entryPoint.to=websecure)
            AA_IDX=$((AA_IDX + 1))
            EXTRA_ARGS+=(--set-string=additionalArguments[${AA_IDX}]=--entrypoints.web.http.redirections.entryPoint.scheme=https)
            AA_IDX=$((AA_IDX + 1))
            EXTRA_ARGS+=(--set-string=additionalArguments[${AA_IDX}]=--entrypoints.web.http.redirections.entryPoint.permanent=true)
            AA_IDX=$((AA_IDX + 1))
          fi

          # Enable dashboard/API only when requested (internal-only service check)
          if [[ "${ENABLE_TRAEFIK_DASHBOARD}" == "true" ]]; then
            # Traefik API/dashboard are not served on :8080 unless explicitly exposed.
            # Use CLI flags to expose /api + /dashboard on the internal 'traefik' entryPoint.
            EXTRA_ARGS+=(--set-string=additionalArguments[${AA_IDX}]=--api=true)
            AA_IDX=$((AA_IDX + 1))
            EXTRA_ARGS+=(--set-string=additionalArguments[${AA_IDX}]=--api.dashboard=true)
            AA_IDX=$((AA_IDX + 1))
            EXTRA_ARGS+=(--set-string=additionalArguments[${AA_IDX}]=--api.insecure=true)
            AA_IDX=$((AA_IDX + 1))
          fi

          helm upgrade --install "${TRAEFIK_RELEASE}" traefik/traefik             --namespace="${TRAEFIK_NAMESPACE}"             --version="${TRAEFIK_CHART_VERSION}"             --values="/tmp/values.traefik.generated.yaml"             "${EXTRA_ARGS[@]}"             --wait --atomic --timeout="${HELM_TIMEOUT}"

          kubectl --namespace="${TRAEFIK_NAMESPACE}" get pods --output=wide
          kubectl --namespace="${TRAEFIK_NAMESPACE}" get svc --output=wide

      - name: Apply Gateway API resources (GatewayClass + Gateway)
        if: ${{ inputs.routing_mode == 'gateway' || inputs.routing_mode == 'both' }}
        shell: bash
        run: |
          set -euo pipefail

          # GatewayClass controllerName for Traefik
          # Reference: traefik.io/gateway-controller
          if [[ "${ENABLE_TLS}" == "true" ]]; then
            : "${TLS_SECRET_NAME:?TLS_SECRET_NAME empty}"
          fi

          if [[ "${GATEWAY_ALLOWED_ROUTES_FROM}" == "Selector" ]]; then
            if [[ "${ENABLE_TLS}" == "true" ]]; then
              cat <<EOF | kubectl apply --filename=-
          apiVersion: gateway.networking.k8s.io/v1
          kind: GatewayClass
          metadata:
            name: traefik
          spec:
            controllerName: traefik.io/gateway-controller
          ---
          apiVersion: gateway.networking.k8s.io/v1
          kind: Gateway
          metadata:
            name: traefik
            namespace: ${TRAEFIK_NAMESPACE}
          spec:
            gatewayClassName: traefik
            listeners:
              - name: web
                protocol: HTTP
                port: ${GATEWAY_LISTENER_WEB_PORT}
                allowedRoutes:
                  namespaces:
                    from: Selector
                    selector:
                      matchLabels:
                        ${GATEWAY_ALLOWED_ROUTES_LABEL_KEY}: "${GATEWAY_ALLOWED_ROUTES_LABEL_VALUE}"
              - name: websecure
                protocol: HTTPS
                port: ${GATEWAY_LISTENER_WEBSECURE_PORT}
                tls:
                  mode: Terminate
                  certificateRefs:
                    - kind: Secret
                      name: ${TLS_SECRET_NAME}
                allowedRoutes:
                  namespaces:
                    from: Selector
                    selector:
                      matchLabels:
                        ${GATEWAY_ALLOWED_ROUTES_LABEL_KEY}: "${GATEWAY_ALLOWED_ROUTES_LABEL_VALUE}"
          EOF
            else
              cat <<EOF | kubectl apply --filename=-
          apiVersion: gateway.networking.k8s.io/v1
          kind: GatewayClass
          metadata:
            name: traefik
          spec:
            controllerName: traefik.io/gateway-controller
          ---
          apiVersion: gateway.networking.k8s.io/v1
          kind: Gateway
          metadata:
            name: traefik
            namespace: ${TRAEFIK_NAMESPACE}
          spec:
            gatewayClassName: traefik
            listeners:
              - name: web
                protocol: HTTP
                port: ${GATEWAY_LISTENER_WEB_PORT}
                allowedRoutes:
                  namespaces:
                    from: Selector
                    selector:
                      matchLabels:
                        ${GATEWAY_ALLOWED_ROUTES_LABEL_KEY}: "${GATEWAY_ALLOWED_ROUTES_LABEL_VALUE}"
          EOF
            fi
          else
            if [[ "${ENABLE_TLS}" == "true" ]]; then
              cat <<EOF | kubectl apply --filename=-
          apiVersion: gateway.networking.k8s.io/v1
          kind: GatewayClass
          metadata:
            name: traefik
          spec:
            controllerName: traefik.io/gateway-controller
          ---
          apiVersion: gateway.networking.k8s.io/v1
          kind: Gateway
          metadata:
            name: traefik
            namespace: ${TRAEFIK_NAMESPACE}
          spec:
            gatewayClassName: traefik
            listeners:
              - name: web
                protocol: HTTP
                port: ${GATEWAY_LISTENER_WEB_PORT}
                allowedRoutes:
                  namespaces:
                    from: ${GATEWAY_ALLOWED_ROUTES_FROM}
              - name: websecure
                protocol: HTTPS
                port: ${GATEWAY_LISTENER_WEBSECURE_PORT}
                tls:
                  mode: Terminate
                  certificateRefs:
                    - kind: Secret
                      name: ${TLS_SECRET_NAME}
                allowedRoutes:
                  namespaces:
                    from: ${GATEWAY_ALLOWED_ROUTES_FROM}
          EOF
            else
              cat <<EOF | kubectl apply --filename=-
          apiVersion: gateway.networking.k8s.io/v1
          kind: GatewayClass
          metadata:
            name: traefik
          spec:
            controllerName: traefik.io/gateway-controller
          ---
          apiVersion: gateway.networking.k8s.io/v1
          kind: Gateway
          metadata:
            name: traefik
            namespace: ${TRAEFIK_NAMESPACE}
          spec:
            gatewayClassName: traefik
            listeners:
              - name: web
                protocol: HTTP
                port: ${GATEWAY_LISTENER_WEB_PORT}
                allowedRoutes:
                  namespaces:
                    from: ${GATEWAY_ALLOWED_ROUTES_FROM}
          EOF
            fi
          fi

          kubectl --namespace="${TRAEFIK_NAMESPACE}" get gateway traefik --output=yaml

      - name: Post-deployment checks (internal readiness + ILB IP)
        shell: bash
        run: |
          set -euo pipefail

          kubectl --namespace="${TRAEFIK_NAMESPACE}" rollout status deploy --selector="app.kubernetes.io/name=traefik" --timeout=5m

          ILB_IP="$(kubectl --namespace="${TRAEFIK_NAMESPACE}" get svc "${TRAEFIK_RELEASE}" --output="jsonpath={.status.loadBalancer.ingress[0].ip}" || true)"
          if [[ -z "${ILB_IP}" ]]; then
            ILB_IP="$(kubectl --namespace="${TRAEFIK_NAMESPACE}" get svc --output=jsonpath='{range .items[?(@.spec.type=="LoadBalancer")]}{.status.loadBalancer.ingress[0].ip}{"\n"}{end}' | head -n 1 || true)"
          fi

          if [[ -z "${ILB_IP}" ]]; then
            echo "ERROR: Traefik service has no ILB IP yet." >&2
            kubectl --namespace="${TRAEFIK_NAMESPACE}" get svc --output=yaml >&2 || true
            exit 1
          fi
          echo "Traefik ILB IP: ${ILB_IP}"
          echo "TRAEFIK_ILB_IP=${ILB_IP}" >> "${GITHUB_ENV}"

      - name: Create internal dashboard service (ClusterIP, port 8080)
        if: ${{ inputs.enable_traefik_dashboard == true }}
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          # We select the Traefik pods using standard Helm labels.
          # Chart instance label pattern for this release is: ${TRAEFIK_RELEASE}-traefik
          INSTANCE_LABEL="${TRAEFIK_RELEASE}-traefik"

          cat <<EOF | kubectl apply --filename=-
          apiVersion: v1
          kind: Service
          metadata:
            name: traefik-dashboard
            namespace: ${TRAEFIK_NAMESPACE}
          spec:
            type: ClusterIP
            selector:
              app.kubernetes.io/name: traefik
              app.kubernetes.io/instance: ${INSTANCE_LABEL}
            ports:
              - name: dashboard
                port: 8080
                targetPort: traefik
                protocol: TCP
          EOF

          kubectl --namespace="${TRAEFIK_NAMESPACE}" get svc traefik-dashboard --output=wide
      - name: "Post-deploy check: Traefik dashboard/API (port-forward -> /api/version)"
        if: ${{ inputs.enable_traefik_dashboard == true }}
        shell: bash
        run: |
          set -euo pipefail
          NS="${TRAEFIK_NAMESPACE}"
          : "${TRAEFIK_TEST_IMAGE:?vars.TRAEFIK_TEST_IMAGE must be set when enable_traefik_dashboard=true}"

          JOB_NAME="traefik-api-check"

          kubectl --namespace="${NS}" delete job "${JOB_NAME}" --ignore-not-found=true

          cat <<EOF | kubectl apply --filename=-
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: ${JOB_NAME}
            namespace: ${NS}
          spec:
            backoffLimit: 0
            template:
              spec:
                restartPolicy: Never
                imagePullSecrets:
                  - name: ${IMAGE_PULL_SECRET_NAME}
                containers:
                  - name: check
                    image: ${TRAEFIK_TEST_IMAGE}
                    command: ["sh","-c"]
                    args:
                      - |
                        set -e
                        echo "Testing Traefik API via ClusterIP service (traefik-dashboard:8080) ..."
                        for u in                           "http://traefik-dashboard:8080/api/version"                           "http://traefik-dashboard.${NS}.svc.cluster.local:8080/api/version"; do
                          if command -v curl >/dev/null 2>&1; then
                            if curl -fsSL --connect-timeout 3 --max-time 5 "\${u}" >/dev/null; then
                              echo "OK: \${u}"
                              exit 0
                            fi
                          elif command -v wget >/dev/null 2>&1; then
                            if wget -qO- "\${u}" >/dev/null; then
                              echo "OK: \${u}"
                              exit 0
                            fi
                          else
                            echo "ERROR: test image has neither curl nor wget." >&2
                            exit 2
                          fi
                        done
                        echo "ERROR: Traefik API not reachable from in-cluster job." >&2
                        exit 1
          EOF

          kubectl --namespace="${NS}" wait --for=condition=complete "job/${JOB_NAME}" --timeout=180s || true
          kubectl --namespace="${NS}" logs "job/${JOB_NAME}" --all-containers=true || true

          SUCCEEDED="$(kubectl --namespace="${NS}" get job "${JOB_NAME}" --output="jsonpath={.status.succeeded}" 2>/dev/null || true)"
          if [[ "${SUCCEEDED}" != "1" ]]; then
            echo "ERROR: Traefik API check job did not succeed." >&2
            kubectl --namespace="${NS}" describe job "${JOB_NAME}" >&2 || true
            kubectl --namespace="${NS}" get pods --selector="job-name=${JOB_NAME}" --output=wide >&2 || true
            exit 1
          fi

          kubectl --namespace="${NS}" delete job "${JOB_NAME}" --ignore-not-found=true

      - name: "Optional: Update Azure Private DNS A record (ingress-traefik -> ILB IP)"
        if: ${{ env.DNS_ENABLED == 'true' }}
        shell: bash
        run: |
          set -euo pipefail

          : "${PRIVATE_DNS_ZONE_SUBSCRIPTION_ID:?PRIVATE_DNS_ZONE_SUBSCRIPTION_ID missing}"
          : "${PRIVATE_DNS_ZONE_RESOURCE_GROUP:?PRIVATE_DNS_ZONE_RESOURCE_GROUP missing}"
          : "${PRIVATE_DNS_ZONE_NAME:?PRIVATE_DNS_ZONE_NAME missing}"

          ILB_IP="${{env.TRAEFIK_ILB_IP}}"
          : "${ILB_IP:?Failed to read ILB IP from service}"

          : "${DEPLOY_CLIENT_ID:?DEPLOY_CLIENT_ID empty}"
          : "${DEPLOY_SECRET:?DEPLOY_SECRET empty}"
          : "${AZURE_TENANT_ID:?AZURE_TENANT_ID empty}"
          : "${AZURE_SUBSCRIPTION_ID:?AZURE_SUBSCRIPTION_ID empty}"

          # Re-login here to ensure Azure CLI has a fresh, valid context
          # before switching subscription for cross-subscription DNS updates.
          az login \
            --service-principal \
            --username="${DEPLOY_CLIENT_ID}" \
            --password="${DEPLOY_SECRET}" \
            --tenant="${AZURE_TENANT_ID}" \
            --output=none
          az account set --subscription="${PRIVATE_DNS_ZONE_SUBSCRIPTION_ID}"

          echo "Checking for existing A record-set '${PRIVATE_DNS_A_RECORD_NAME}' in zone '${PRIVATE_DNS_ZONE_NAME}'..."
          if az network private-dns record-set a show \
            --resource-group="${PRIVATE_DNS_ZONE_RESOURCE_GROUP}" \
            --zone-name="${PRIVATE_DNS_ZONE_NAME}" \
            --name="${PRIVATE_DNS_A_RECORD_NAME}" \
            --only-show-errors \
            --output=none; then
            echo "Record-set already exists; skipping create."
          else
            echo "Record-set not found; creating..."
            az network private-dns record-set a create \
              --resource-group="${PRIVATE_DNS_ZONE_RESOURCE_GROUP}" \
              --zone-name="${PRIVATE_DNS_ZONE_NAME}" \
              --name="${PRIVATE_DNS_A_RECORD_NAME}" \
              --ttl=60 \
              --output=none
          fi

          echo "Reading existing A records for ${PRIVATE_DNS_A_RECORD_NAME}.${PRIVATE_DNS_ZONE_NAME}..."
          EXISTING="$(
            az network private-dns record-set a show \
              --resource-group="${PRIVATE_DNS_ZONE_RESOURCE_GROUP}" \
              --zone-name="${PRIVATE_DNS_ZONE_NAME}" \
              --name="${PRIVATE_DNS_A_RECORD_NAME}" \
              --query="aRecords[].ipv4Address" \
              --output=tsv 2>/dev/null || true
          )"

          if [[ -n "${EXISTING}" ]]; then
            echo "Removing existing A records:"
            while IFS= read -r ip; do
              [[ -z "${ip}" ]] && continue
              echo " - ${ip}"
              az network private-dns record-set a remove-record \
                --resource-group="${PRIVATE_DNS_ZONE_RESOURCE_GROUP}" \
                --zone-name="${PRIVATE_DNS_ZONE_NAME}" \
                --record-set-name="${PRIVATE_DNS_A_RECORD_NAME}" \
                --ipv4-address="${ip}" \
                --output=none \
                --only-show-errors || true
            done <<< "${EXISTING}"
          else
            echo "No existing A records found."
          fi

          echo "Adding A record ${ILB_IP}..."
          az network private-dns record-set a add-record \
            --resource-group="${PRIVATE_DNS_ZONE_RESOURCE_GROUP}" \
            --zone-name="${PRIVATE_DNS_ZONE_NAME}" \
            --record-set-name="${PRIVATE_DNS_A_RECORD_NAME}" \
            --ipv4-address="${ILB_IP}" \
            --output=none \
            --only-show-errors
            
          echo "Updated Private DNS: ${PRIVATE_DNS_A_RECORD_NAME}.${PRIVATE_DNS_ZONE_NAME} -> ${ILB_IP}"
