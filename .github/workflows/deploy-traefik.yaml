name: Deploy Traefik Ingress (AKS)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: GitHub Environment to use
        required: true
        type: choice
        options:
          - dev
          - preprod
          - prod
      aks_resource_group:
        description: AKS resource group (optional; defaults to vars.AKS_RESOURCE_GROUP)
        required: false
        type: string
        default: ""
      aks_cluster_name:
        description: AKS cluster name (optional; defaults to vars.AKS_CLUSTER_NAME)
        required: false
        type: string
        default: ""
      use_admin_credentials:
        description: Use AKS admin kubeconfig (bypasses Entra auth; not recommended for day-2 unless required)
        required: false
        type: boolean
        default: false
      traefik_chart_version:
        description: Traefik chart version (optional; defaults to vars.TRAEFIK_CHART_VERSION)
        required: false
        type: string
        default: ""
      helm_timeout:
        description: Helm timeout (optional; defaults to vars.HELM_TIMEOUT)
        required: false
        type: string
        default: ""

concurrency:
  group: traefik-ingress-deploy
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  deploy:
    name: Deploy Traefik Ingress
    runs-on: self-hosted
    environment: ${{ inputs.environment }}
    timeout-minutes: 30

    env:
      TRAEFIK_NAMESPACE: traefik
      TRAEFIK_RELEASE: traefik

      # Repo/Environment variables (non-secret defaults)
      AKS_RESOURCE_GROUP: ${{ inputs.aks_resource_group || vars.AKS_RESOURCE_GROUP }}
      AKS_CLUSTER_NAME: ${{ inputs.aks_cluster_name || vars.AKS_CLUSTER_NAME }}
      TRAEFIK_CHART_VERSION: ${{ inputs.traefik_chart_version || vars.TRAEFIK_CHART_VERSION }}
      HELM_TIMEOUT: ${{ inputs.helm_timeout || vars.HELM_TIMEOUT }}

      # Helm chart repo (optional override; defaults to upstream)
      TRAEFIK_HELM_REPO_URL: ${{ vars.TRAEFIK_HELM_REPO_URL || 'https://traefik.github.io/charts' }}

      # Azure SP auth (GHES is firewalled; do not use OIDC federation)
      AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      DEPLOY_CLIENT_ID: ${{ secrets.DEPLOY_CLIENT_ID }}
      DEPLOY_SECRET: ${{ secrets.DEPLOY_SECRET }}

      # Nexus registry for container images (required)
      REGISTRY_SERVER: ${{ secrets.REGISTRY_SERVER }}
      REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME }}
      REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
      IMAGE_PULL_SECRET_NAME: ${{ secrets.IMAGE_PULL_SECRET_NAME }}

      # Traefik image override (non-secret; set to your Nexus repo path if required)
      TRAEFIK_IMAGE_REPOSITORY: ${{ vars.TRAEFIK_IMAGE_REPOSITORY || 'traefik/traefik' }}
      TRAEFIK_IMAGE_TAG: ${{ vars.TRAEFIK_IMAGE_TAG || '' }}

      # Optional: pin a specific ILB IP (must be free in subnet). If unset, Azure assigns.
      TRAEFIK_LB_IPV4: ${{ vars.TRAEFIK_LB_IPV4 || '' }}

      # Optional DNS update (Azure Private DNS) - values from vars preferred, secrets allowed for backward compatibility
      DNS_ENABLED: ${{ secrets.DNS_ENABLED }}
      PRIVATE_DNS_ZONE_SUBSCRIPTION_ID: ${{ vars.PRIVATE_DNS_ZONE_SUBSCRIPTION_ID || secrets.PRIVATE_DNS_ZONE_SUBSCRIPTION_ID }}
      PRIVATE_DNS_ZONE_RESOURCE_GROUP: ${{ vars.PRIVATE_DNS_ZONE_RESOURCE_GROUP || secrets.PRIVATE_DNS_ZONE_RESOURCE_GROUP }}
      PRIVATE_DNS_ZONE_NAME: ${{ vars.PRIVATE_DNS_ZONE_NAME || secrets.PRIVATE_DNS_ZONE_NAME }}
      PRIVATE_DNS_A_RECORD_NAME: ${{ vars.PRIVATE_DNS_A_RECORD_NAME || secrets.PRIVATE_DNS_A_RECORD_NAME }}

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: "Verify toolchain on runner"
        shell: bash
        run: |
          set -euo pipefail
          command -v az >/dev/null
          command -v kubectl >/dev/null
          command -v helm >/dev/null
          command -v kubelogin >/dev/null
          az version
          kubectl version --client=true
          helm version
          kubelogin --version

      - name: "Validate required secrets (non-empty)"

        shell: bash

        run: |

          set -euo pipefail

          # GitHub Actions renders missing secrets as empty strings. Fail fast with a clear error.

          required=(AZURE_TENANT_ID AZURE_SUBSCRIPTION_ID DEPLOY_CLIENT_ID DEPLOY_SECRET)

          for k in "${required[@]}"; do

            if [[ -z "${!k:-}" ]]; then

              echo "ERROR: ${k} is not set or empty. Ensure it exists as a Secret in the selected GitHub Environment (or repo secret) with the exact name."

              exit 1

            fi

          done


      - name: "Azure login (Service Principal + secret)"
        shell: bash
        run: |
          set -euo pipefail
          # Defensive: ensure secrets are non-empty before calling az login
          : "${DEPLOY_CLIENT_ID:?DEPLOY_CLIENT_ID empty}"
          : "${DEPLOY_SECRET:?DEPLOY_SECRET empty}"
          : "${AZURE_TENANT_ID:?AZURE_TENANT_ID empty}"
          : "${AZURE_SUBSCRIPTION_ID:?AZURE_SUBSCRIPTION_ID empty}"

          az login \
            --service-principal \
            --username="${DEPLOY_CLIENT_ID}" \
            --password="${DEPLOY_SECRET}" \
            --tenant="${AZURE_TENANT_ID}" \
            --output none
          az account set --subscription "${AZURE_SUBSCRIPTION_ID}"

      - name: "Validate required variables"
        shell: bash
        run: |
          set -euo pipefail
          : "${AKS_RESOURCE_GROUP:?Set inputs.aks_resource_group or vars.AKS_RESOURCE_GROUP}"
          : "${AKS_CLUSTER_NAME:?Set inputs.aks_cluster_name or vars.AKS_CLUSTER_NAME}"
          : "${TRAEFIK_CHART_VERSION:?Set inputs.traefik_chart_version or vars.TRAEFIK_CHART_VERSION}"
          : "${HELM_TIMEOUT:?Set inputs.helm_timeout or vars.HELM_TIMEOUT}"
          # Normalize HELM_TIMEOUT:
          # - Helm expects a Go duration (e.g., 10m, 600s, 1h). A bare integer like "10" is invalid.
          # - For convenience, if HELM_TIMEOUT is digits-only, treat it as minutes.
          if [[ "${HELM_TIMEOUT}" =~ ^[0-9]+$ ]]; then
            HELM_TIMEOUT="${HELM_TIMEOUT}m"
          fi

          # Basic format guard (digits + unit), allow composite Go durations as well (e.g., 1h30m).
          if ! [[ "${HELM_TIMEOUT}" =~ ^[0-9]+[smhd]([0-9]+[smhd])*$ ]]; then
            echo "ERROR: HELM_TIMEOUT must be a Go duration like '10m', '600s', '1h30m'. Got: '${HELM_TIMEOUT}'"
            exit 1
          fi

          echo "HELM_TIMEOUT=${HELM_TIMEOUT}" >> "${GITHUB_ENV}"

      - name: Get AKS credentials
        shell: bash
        run: |
          set -euo pipefail

          ADMIN_FLAG=""
          if [[ "${{ inputs.use_admin_credentials }}" == "true" ]]; then
            ADMIN_FLAG="--admin"
          fi

          az aks get-credentials \
            --resource-group "${AKS_RESOURCE_GROUP}" \
            --name "${AKS_CLUSTER_NAME}" \
            ${ADMIN_FLAG} \
            --overwrite-existing

      - name: "Configure kubelogin (SPN)"

        if: ${{ inputs.use_admin_credentials != true }}

        shell: bash

        run: |

          set -euo pipefail


          # Convert kubeconfig to non-interactive SPN login to avoid device-code prompts.

          # Secrets are passed via env vars; do not echo them.

          kubelogin convert-kubeconfig                   -l spn                   --client-id "${DEPLOY_CLIENT_ID}"                   --client-secret "${DEPLOY_SECRET}"                   --tenant-id "${AZURE_TENANT_ID}"

      - name: "Preflight: Kubernetes API reachable"

        shell: bash

        run: |

          set -euo pipefail


          # If the AKS API server is private, a runner outside the VNet will hang on kubectl calls.

          # Keep timeouts low so failures surface as errors, not indefinite hangs.

          timeout 30s kubectl version --client=true --request-timeout=20s

          timeout 30s kubectl cluster-info --request-timeout=20s

          timeout 30s kubectl get nodes -o wide --request-timeout=20s


      - name: Ensure Traefik namespace
        shell: bash
        run: |
          set -euo pipefail

          # Use explicit timeouts so a private API / network issue fails fast instead of hanging.
          if timeout 30s kubectl get namespace "${TRAEFIK_NAMESPACE}" --request-timeout=20s >/dev/null 2>&1; then
            exit 0
          fi

          timeout 30s kubectl create namespace "${TRAEFIK_NAMESPACE}" --dry-run=client -o yaml               | timeout 30s kubectl apply --request-timeout=20s -f -

      - name: Create/update imagePullSecret (Nexus) in Traefik namespace
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          kubectl -n "${TRAEFIK_NAMESPACE}" create secret docker-registry "${IMAGE_PULL_SECRET_NAME}" \
            --docker-server="${REGISTRY_SERVER}" \
            --docker-username="${REGISTRY_USERNAME}" \
            --docker-password="${REGISTRY_PASSWORD}" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Render Helm values (no secret material printed)
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          python3 - <<'PY'
          import os, pathlib
          tpl = pathlib.Path('helm/traefik/values.template.yaml').read_text(encoding='utf-8')
          repl = {
            '<IMAGE_PULL_SECRET_NAME>': os.environ['IMAGE_PULL_SECRET_NAME'],
            '<REGISTRY_SERVER>': os.environ['REGISTRY_SERVER'],
            '<TRAEFIK_IMAGE_REPOSITORY>': os.environ['TRAEFIK_IMAGE_REPOSITORY'],
            '<TRAEFIK_IMAGE_TAG>': os.environ.get('TRAEFIK_IMAGE_TAG',''),
          }
          for k,v in repl.items():
            tpl = tpl.replace(k, v)
          out = pathlib.Path('/tmp/values.traefik.generated.yaml')
          out.write_text(tpl, encoding='utf-8')
          PY

          chmod 600 /tmp/values.traefik.generated.yaml

      - name: Install/upgrade Traefik (official chart; images pulled from Nexus)
        shell: bash
        run: |
          set -euo pipefail

          helm repo add traefik "${TRAEFIK_HELM_REPO_URL}"
          helm repo update

          helm upgrade --install "${TRAEFIK_RELEASE}" traefik/traefik \
            --namespace "${TRAEFIK_NAMESPACE}" \
            --version "${TRAEFIK_CHART_VERSION}" \
            --values /tmp/values.traefik.generated.yaml \
            --wait --atomic --timeout "${HELM_TIMEOUT}"

          timeout 30s kubectl -n "${TRAEFIK_NAMESPACE}" get pods -o wide --request-timeout=20s
          timeout 30s kubectl -n "${TRAEFIK_NAMESPACE}" get svc "${TRAEFIK_RELEASE}" -o wide --request-timeout=20s

      - name: Post-deployment checks (internal readiness + ILB IP)
        shell: bash
        run: |
          set -euo pipefail

          kubectl -n "${TRAEFIK_NAMESPACE}" rollout status deploy/"${TRAEFIK_RELEASE}" --timeout=5m

          ILB_IP="$(timeout 30s kubectl -n "${TRAEFIK_NAMESPACE}" get svc "${TRAEFIK_RELEASE}" --request-timeout=20s -o jsonpath='{.status.loadBalancer.ingress[0].ip}')"
          if [[ -z "${ILB_IP}" ]]; then
            echo "ERROR: Traefik service has no ILB IP yet."
            kubectl -n "${TRAEFIK_NAMESPACE}" get svc "${TRAEFIK_RELEASE}" -o yaml
            exit 1
          fi
          echo "Traefik ILB IP: ${ILB_IP}"

      - name: Post-deployment checks (dashboard/API via port-forward)
        shell: bash
        run: |
          set -euo pipefail

          # Best-effort connectivity test only (dashboard is not exposed via IngressRoute).
          # We accept any HTTP status except 000 (connection failure).

          try_port_forward() {
            local target_port="$1"
            local local_port="19000"

            kubectl -n "${TRAEFIK_NAMESPACE}" port-forward deploy/"${TRAEFIK_RELEASE}" "${local_port}:${target_port}" >/tmp/portforward.log 2>&1 &
            local pf_pid=$!

            # Wait briefly for port-forward to come up
            sleep 2

            # If port-forward died immediately, this port is not valid
            if ! kill -0 "${pf_pid}" 2>/dev/null; then
              return 1
            fi

            local code
            code="$(curl -sS -o /dev/null -w %{http_code} http://127.0.0.1:${local_port}/ || true)"

            kill "${pf_pid}" >/dev/null 2>&1 || true
            wait "${pf_pid}" >/dev/null 2>&1 || true

            if [[ "${code}" != "000" ]]; then
              echo "Traefik port-forward OK on ${target_port} (HTTP ${code})"
              return 0
            fi

            return 1
          }

          if try_port_forward 9000; then exit 0; fi
          if try_port_forward 8080; then exit 0; fi

          echo "ERROR: Traefik dashboard/API port-forward failed on 9000 and 8080."
          echo "port-forward logs:"
          cat /tmp/portforward.log || true
          exit 1

      - name: "Optional: Update Azure Private DNS A record (ingress-traefik -> ILB IP)"
        if: ${{ env.DNS_ENABLED == 'true' }}
        shell: bash
        run: |
          set -euo pipefail

          : "${PRIVATE_DNS_ZONE_SUBSCRIPTION_ID:?PRIVATE_DNS_ZONE_SUBSCRIPTION_ID missing}"
          : "${PRIVATE_DNS_ZONE_RESOURCE_GROUP:?PRIVATE_DNS_ZONE_RESOURCE_GROUP missing}"
          : "${PRIVATE_DNS_ZONE_NAME:?PRIVATE_DNS_ZONE_NAME missing}"

          RECORD_NAME="${PRIVATE_DNS_A_RECORD_NAME:-ingress-traefik}"
          ILB_IP="$(timeout 30s kubectl -n "${TRAEFIK_NAMESPACE}" get svc "${TRAEFIK_RELEASE}" --request-timeout=20s -o jsonpath='{.status.loadBalancer.ingress[0].ip}')"
          : "${ILB_IP:?Failed to read ILB IP from service}"

          # DNS zone may live in a different subscription to the AKS cluster.
          az account set --subscription "${PRIVATE_DNS_ZONE_SUBSCRIPTION_ID}"

          az network private-dns record-set a create \
            -g "${PRIVATE_DNS_ZONE_RESOURCE_GROUP}" \
            -z "${PRIVATE_DNS_ZONE_NAME}" \
            -n "${RECORD_NAME}" \
            --ttl 60 \
            --output none

          EXISTING="$(az network private-dns record-set a show \
            -g "${PRIVATE_DNS_ZONE_RESOURCE_GROUP}" \
            -z "${PRIVATE_DNS_ZONE_NAME}" \
            -n "${RECORD_NAME}" \
            --query "arecords[].ipv4Address" -o tsv || true)"

          if [[ -n "${EXISTING}" ]]; then
            while read -r ip; do
              [[ -z "${ip}" ]] && continue
              az network private-dns record-set a remove-record \
                -g "${PRIVATE_DNS_ZONE_RESOURCE_GROUP}" \
                -z "${PRIVATE_DNS_ZONE_NAME}" \
                -n "${RECORD_NAME}" \
                --ipv4-address "${ip}" \
                --output none || true
            done <<< "${EXISTING}"
          fi

          az network private-dns record-set a add-record \
            -g "${PRIVATE_DNS_ZONE_RESOURCE_GROUP}" \
            -z "${PRIVATE_DNS_ZONE_NAME}" \
            -n "${RECORD_NAME}" \
            --ipv4-address "${ILB_IP}" \
            --output none

          echo "Updated Private DNS A record: ${RECORD_NAME}.${PRIVATE_DNS_ZONE_NAME} -> ${ILB_IP}"
