name: Deploy Traefik Ingress (AKS)

on:
  workflow_dispatch:
    inputs:
      environment:
        description: GitHub Environment to use (e.g., dev)
        required: true
        type: string
      aks_resource_group:
        description: AKS resource group
        required: true
        type: string
      aks_cluster_name:
        description: AKS cluster name
        required: true
        type: string
      use_admin_credentials:
        description: Use AKS admin kubeconfig (adds --admin to az aks get-credentials)
        required: false
        type: boolean
        default: false
      traefik_chart_version:
        description: Traefik chart version (pin)
        required: true
        type: string
        default: "38.0.1"
      helm_timeout:
        description: Helm timeout (e.g., 10m)
        required: true
        type: string
        default: "10m"

concurrency:
  group: traefik-ingress-deploy
  cancel-in-progress: false

permissions:
  contents: read

jobs:
  deploy:
    name: Deploy Traefik Ingress
    runs-on: self-hosted
    environment: ${{ inputs.environment }}
    timeout-minutes: 30

    env:
      TRAEFIK_NAMESPACE: traefik
      TRAEFIK_RELEASE: traefik

      # If you proxy charts via Nexus, set this to your Nexus Helm repo URL.
      TRAEFIK_HELM_REPO_URL: "https://traefik.github.io/charts"

      # Azure SP auth (GHES is firewalled; do not use OIDC federation)
      AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      DEPLOY_CLIENT_ID: ${{ secrets.DEPLOY_CLIENT_ID }}
      DEPLOY_SECRET: ${{ secrets.DEPLOY_SECRET }}

      # Nexus registry for container images (required)
      REGISTRY_SERVER: ${{ secrets.REGISTRY_SERVER }}
      REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME }}
      REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
      IMAGE_PULL_SECRET_NAME: ${{ secrets.IMAGE_PULL_SECRET_NAME }}

      # Traefik image override (non-secret; keep in env for easy override)
      TRAEFIK_IMAGE_REPOSITORY: "traefik/traefik"
      TRAEFIK_IMAGE_TAG: ""  # optional; if empty chart uses appVersion

      # Optional DNS update (Azure Private DNS)
      DNS_ENABLED: ${{ secrets.DNS_ENABLED }}
      PRIVATE_DNS_ZONE_RESOURCE_GROUP: ${{ secrets.PRIVATE_DNS_ZONE_RESOURCE_GROUP }}
      PRIVATE_DNS_ZONE_NAME: ${{ secrets.PRIVATE_DNS_ZONE_NAME }}
      PRIVATE_DNS_A_RECORD_NAME: ${{ secrets.PRIVATE_DNS_A_RECORD_NAME }}

      # Optional: pin a specific ILB IP by setting this (must be free in subnet)
      # (If empty, AKS assigns an IP; DNS update handles stability at the name level.)
      TRAEFIK_LB_IPV4: ""

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4

      - name: Setup Helm
        uses: azure/setup-helm@v4

      - name: Azure login (Service Principal + secret)
        uses: azure/login@v2
        with:
          client-id: ${{ env.DEPLOY_CLIENT_ID }}
          tenant-id: ${{ env.AZURE_TENANT_ID }}
          subscription-id: ${{ env.AZURE_SUBSCRIPTION_ID }}
          client-secret: ${{ env.DEPLOY_SECRET }}

      - name: Get AKS credentials
        shell: bash
        run: |
          set -euo pipefail
          az account set --subscription "${AZURE_SUBSCRIPTION_ID}"

          ADMIN_FLAG=""
          if [[ "${{ inputs.use_admin_credentials }}" == "true" ]]; then
            ADMIN_FLAG="--admin"
          fi

          az aks get-credentials \
            --resource-group "${{ inputs.aks_resource_group }}" \
            --name "${{ inputs.aks_cluster_name }}" \
            ${ADMIN_FLAG} \
            --overwrite-existing

          kubectl version --client=true

      - name: Ensure Traefik namespace
        shell: bash
        run: |
          set -euo pipefail
          kubectl get namespace "${TRAEFIK_NAMESPACE}" >/dev/null 2>&1 || kubectl create namespace "${TRAEFIK_NAMESPACE}"

      - name: Create/update imagePullSecret (Nexus) in Traefik namespace
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          python3 - <<'PY'
          import os, json, base64
          server = os.environ["REGISTRY_SERVER"]
          user = os.environ["REGISTRY_USERNAME"]
          pw = os.environ["REGISTRY_PASSWORD"]

          cfg = {
            "auths": {
              server: {
                "username": user,
                "password": pw,
                "auth": base64.b64encode(f"{user}:{pw}".encode()).decode(),
              }
            }
          }
          open("dockerconfigjson","w",encoding="utf-8").write(json.dumps(cfg))
          PY

          kubectl -n "${TRAEFIK_NAMESPACE}" create secret generic "${IMAGE_PULL_SECRET_NAME}" \
            --type="kubernetes.io/dockerconfigjson" \
            --from-file=".dockerconfigjson=dockerconfigjson" \
            --dry-run=client -o yaml | kubectl apply -f -

          rm -f dockerconfigjson

      - name: Render Helm values (no secrets printed)
        shell: bash
        run: |
          set -euo pipefail
          umask 077

          python3 - <<'PY'
          import os

          def y(s: str) -> str:
            if s is None:
              return '""'
            s = str(s)
            s = s.replace('\\\\', '\\\\\\\\').replace('"', '\\"')
            return f'"{s}"'

          image_pull_secret = os.environ["IMAGE_PULL_SECRET_NAME"]
          registry = os.environ["REGISTRY_SERVER"]
          repo = os.environ.get("TRAEFIK_IMAGE_REPOSITORY", "traefik/traefik")
          tag = os.environ.get("TRAEFIK_IMAGE_TAG", "")
          lb_ip = os.environ.get("TRAEFIK_LB_IPV4", "")

          lines = []
          lines.append("imagePullSecrets:")
          lines.append(f"  - name: {y(image_pull_secret)}")
          lines.append("")
          lines.append("image:")
          lines.append(f"  registry: {y(registry)}")
          lines.append(f"  repository: {y(repo)}")
          if tag.strip():
            lines.append(f"  tag: {y(tag.strip())}")
          lines.append("")
          lines.append("ingressClass:")
          lines.append("  enabled: true")
          lines.append("  isDefaultClass: false")
          lines.append("  name: \"traefik\"")
          lines.append("")
          lines.append("providers:")
          lines.append("  kubernetesIngress:")
          lines.append("    enabled: true")
          lines.append("  kubernetesCRD:")
          lines.append("    enabled: true")
          lines.append("")
          lines.append("service:")
          lines.append("  enabled: true")
          lines.append("  type: LoadBalancer")
          lines.append("  annotations:")
          lines.append("    service.beta.kubernetes.io/azure-load-balancer-internal: \"true\"")
          if lb_ip.strip():
            lines.append(f"    service.beta.kubernetes.io/azure-load-balancer-ipv4: {y(lb_ip.strip())}")
          lines.append("")
          lines.append("ports:")
          lines.append("  web:")
          lines.append("    expose: true")
          lines.append("    exposedPort: 80")
          lines.append("  websecure:")
          lines.append("    expose: true")
          lines.append("    exposedPort: 443")
          lines.append("  traefik:")
          lines.append("    expose: false")
          lines.append("")
          lines.append("ingressRoute:")
          lines.append("  dashboard:")
          lines.append("    enabled: false")
          lines.append("")
          lines.append("additionalArguments:")
          lines.append("  - \"--providers.kubernetesingress.ingressclass=traefik\"")
          lines.append("  - \"--providers.kubernetescrd.ingressclass=traefik\"")
          lines.append("")

          out = "/tmp/values.traefik.generated.yaml"
          with open(out, "w", encoding="utf-8") as f:
            f.write("\n".join(lines))

          os.chmod(out, 0o600)
          PY

      - name: Install/upgrade Traefik (official chart; images pulled from Nexus)
        shell: bash
        run: |
          set -euo pipefail

          helm repo add traefik "${TRAEFIK_HELM_REPO_URL}"
          helm repo update

          helm upgrade --install "${TRAEFIK_RELEASE}" traefik/traefik \
            --namespace "${TRAEFIK_NAMESPACE}" \
            --version "${{ inputs.traefik_chart_version }}" \
            --values /tmp/values.traefik.generated.yaml \
            --wait --atomic --timeout "${{ inputs.helm_timeout }}"

          kubectl -n "${TRAEFIK_NAMESPACE}" get pods -o wide

      - name: Wait for internal LoadBalancer IP
        shell: bash
        run: |
          set -euo pipefail

          SVC="${TRAEFIK_RELEASE}"
          for i in {1..60}; do
            IP="$(kubectl -n "${TRAEFIK_NAMESPACE}" get svc "${SVC}" -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || true)"
            if [[ -n "${IP}" ]]; then
              echo "Traefik internal LB IP: ${IP}"
              echo "TRAEFIK_LB_IP=${IP}" >> "${GITHUB_ENV}"
              exit 0
            fi
            sleep 5
          done

          echo "Timed out waiting for Traefik LoadBalancer IP." >&2
          kubectl -n "${TRAEFIK_NAMESPACE}" get svc "${SVC}" -o yaml >&2 || true
          exit 1

      - name: "Optional: Update Azure Private DNS A record (ingress-traefik -> ILB IP)"
        if: ${{ env.DNS_ENABLED == 'true' }}
        shell: bash
        run: |
          set -euo pipefail

          : "${PRIVATE_DNS_ZONE_RESOURCE_GROUP:?PRIVATE_DNS_ZONE_RESOURCE_GROUP missing}"
          : "${PRIVATE_DNS_ZONE_NAME:?PRIVATE_DNS_ZONE_NAME missing}"

          RECORD_NAME="${PRIVATE_DNS_A_RECORD_NAME:-ingress-traefik}"
          IP="${TRAEFIK_LB_IP:?TRAEFIK_LB_IP missing}"

          # Replace recordset for idempotency (avoids stale IPs accumulating)
          az network private-dns record-set a delete \
            -g "${PRIVATE_DNS_ZONE_RESOURCE_GROUP}" \
            -z "${PRIVATE_DNS_ZONE_NAME}" \
            -n "${RECORD_NAME}" \
            --yes || true

          az network private-dns record-set a add-record \
            -g "${PRIVATE_DNS_ZONE_RESOURCE_GROUP}" \
            -z "${PRIVATE_DNS_ZONE_NAME}" \
            -n "${RECORD_NAME}" \
            -a "${IP}"

          echo "Updated Private DNS: ${RECORD_NAME}.${PRIVATE_DNS_ZONE_NAME} -> ${IP}"

      - name: "Post-deploy check: Traefik dashboard/API reachable via port-forward"
        shell: bash
        run: |
          set -euo pipefail

          POD="$(kubectl -n "${TRAEFIK_NAMESPACE}" get pod \
            -l app.kubernetes.io/name=traefik \
            -o jsonpath='{.items[0].metadata.name}')"

          echo "Port-forwarding to Traefik pod: ${POD}"

          kubectl -n "${TRAEFIK_NAMESPACE}" port-forward "pod/${POD}" 8080:8080 >/tmp/traefik-portforward.log 2>&1 &
          PF_PID=$!

          cleanup() {
            kill "${PF_PID}" >/dev/null 2>&1 || true
          }
          trap cleanup EXIT

          sleep 3

          if curl -fsS --max-time 5 "http://127.0.0.1:8080/api/version" >/dev/null 2>&1; then
            echo "Traefik API reachable on 127.0.0.1:8080/api/version"
            exit 0
          fi

          if curl -fsS --max-time 5 "http://127.0.0.1:8080/dashboard/" >/dev/null 2>&1; then
            echo "Traefik dashboard reachable on 127.0.0.1:8080/dashboard/"
            exit 0
          fi

          echo "Traefik dashboard/API check failed. Port-forward log (tail):" >&2
          tail -n 50 /tmp/traefik-portforward.log >&2 || true
          exit 1
